# コンパイルと実行

### 1. はじめに：Javaの「一度書けばどこでも動く」

Javaが多くのシステムで利用される理由の一つに、「Write Once, Run Anywhere (一度書けばどこでも動く)」という特徴があります。  
これは、Javaのプログラムが直接OSやCPUの機械語に変換されるのではなく、**コンパイル**と**実行**という二段階のプロセスを踏むことで実現されます。  

|用語　　　　|説明|
|---|---|
|**コンパイル**|人間が書いたJavaのソースコード（`.java`ファイル）を、Java Virtual Machine (JVM) が理解できる「バイトコード」（`.class`ファイル）に変換するプロセスです。  このバイトコードは、特定のOSやCPUに依存しない共通の形式です。|
|**実行**|バイトコードを、各OSにインストールされたJVMが読み込み、そのOS上でプログラムを実行するプロセスです。  これにより、同じバイトコードがWindowsでもmacOSでもLinuxでも動く、という仕組みが成り立ちます。|

このクロスプラットフォーム性は、Javaが多様な環境で利用される大きな強みです。  
開発者は一度コードを書けば、特定のプラットフォーム向けの調整を最小限に抑え、幅広いユーザーにアプリケーションを提供できます。  

この資料では、Javaのプログラムがどのように書かれ、どのようにコンピュータによって実行されるのかを、具体的なサンプルコードを使って解説します。  

### 2. 準備：JDK（Java Development Kit）

Javaプログラムの開発と実行には、先の手順でインストールした**JDK (Java Development Kit)** が必要です。  
JDKには、Javaのプログラムをコンパイルするための`javac`コマンドや、実行するための`java`コマンドなどが含まれています。  

これらのコマンドが正しく動作しない場合、JDKが適切にインストールされていないか、環境変数`PATH`が正しく設定されていない可能性があります。  
`PATH`は、OSがコマンドを実行する際にどのディレクトリを探しに行くかを指定する重要な環境変数です。  
JDKのインストール時に自動設定されることが多いですが、手動での設定が必要な場合もあります。  

### 3. サンプルコードの作成

今回はコマンドライン引数を受け取って簡単なメッセージを表示するプログラムを作成します。  

#### ファイル名: `MyFirstJavaApp.java`

```java  showLineNumbers
/**
 * MyFirstJavaApp.java
 *
 * このプログラムは、Javaにおけるコンパイルと実行の基本的な流れを示すサンプルです。
 * コマンドライン引数があればそれを表示し、なければ標準の挨拶を表示します。
 */
public class MyFirstJavaApp {

    /**
     * Javaプログラムのエントリポイント（ここから実行が開始される）。
     *
     * @param args コマンドライン引数が格納されるString型の配列
     */
    public static void main(String[] args) {
        // メイン処理の開始をログに出力
        System.out.println("--- Javaプログラムを開始します ---");

        // コマンドライン引数があるかチェック
        if (args.length > 0) {
            // 引数がある場合、それらを結合して表示
            System.out.println("こんにちは、" + String.join(" と ", args) + "さん！");
            System.out.println("引数として以下の値が渡されました：");
            for (int i = 0; i < args.length; i++) {
                System.out.println("  args[" + i + "] = \"" + args[i] + "\"");
            }
        } else {
            // 引数がない場合、一般的なメッセージを表示
            System.out.println("こんにちは、Javaの世界へようこそ！");
            System.out.println("引数を指定して実行することもできます。例: java MyFirstJavaApp Alice Bob");
        }

        // プログラムの終了をログに出力
        System.out.println("--- Javaプログラムを終了します ---");
    }
}
```

**詳細解説:**  

このサンプルコードは、Javaプログラムの基本的な構造と、コマンドライン引数の処理方法を示しています。  

#### コメントとドキュメンテーション

```java  showLineNumbers
/**
 * MyFirstJavaApp.java
 *
 * このプログラムは、Javaにおけるコンパイルと実行の基本的な流れを示すサンプルです。
 * コマンドライン引数があればそれを表示し、なければ標準の挨拶を表示します。
 */
```
*   `/** ... */`:   
これはJavadocコメントと呼ばれる特別な形式のコメントです。  
Javadocコメントは、`javadoc`コマンドを使って自動的にAPIドキュメントを生成するために使用されます。  
クラス、メソッド、フィールドなどの説明を記述し、プログラムの可読性と保守性を高めます。  
通常、プログラムの目的、作成者、バージョンなどを記述します。  

#### クラス定義

```java  showLineNumbers
public class MyFirstJavaApp {
    // ... クラスの内容 ...
}
```
|項目　　　　|説明|
|---|---|
|`public`| アクセス修飾子の一つで、このクラスがどのパッケージからでもアクセス可能であることを示します。  Javaでは、クラス、メソッド、フィールドなどの公開範囲を制御するためにアクセス修飾子を使用します。  |
|`class`|Javaで新しいクラスを定義するためのキーワードです。  Javaのすべてのプログラムはクラスの中に記述されます。  |
|`MyFirstJavaApp`|クラス名です。  Javaの命名規則では、クラス名はパスカルケース（各単語の先頭を大文字にする）で記述することが推奨されています（例: `MyFirstJavaApp`）。  また、`public`クラスの場合、そのクラスを含む**ファイル名とクラス名が完全に一致**している必要があります（例: `MyFirstJavaApp.java`）。  |

#### メインメソッド（エントリポイント）

```java  showLineNumbers
    /**
     * Javaプログラムのエントリポイント（ここから実行が開始される）。
     *
     * @param args コマンドライン引数が格納されるString型の配列
     */
    public static void main(String[] args) {
        // ... メソッドの内容 ...
    }
```
*   `public static void main(String[] args)`: これはJavaプログラムのエントリポイント（プログラムの実行開始地点）となる特別なメソッドです。  JVMは、プログラムを実行する際に、指定されたクラスのこの`main`メソッドを探して実行を開始します。  このメソッドのシグネチャ（定義）は厳密にこの形である必要があります。 

|項目　　　　|説明|
|---|---|
|`public`|このメソッドがJVMから呼び出されるため、どの場所からでもアクセス可能である必要があります。  |
|`static`|このメソッドが静的メソッドであることを示します。  静的メソッドは、クラスのインスタンス（オブジェクト）を作成せずに直接クラス名を使って呼び出すことができます。  JVMは`main`メソッドを実行するためにオブジェクトを生成しないため、`static`である必要があります。  |
|`void`|このメソッドが、呼び出し元に何も値を返さないことを示します。  プログラムが終了する際に、特に戻り値を必要としない場合に`void`を指定します。  |
|`main`|メソッド名です。  JVMはエントリポイントとしてこの名前のメソッドを探します。  |
|`String[] args`|このメソッドが受け取る引数です。  コマンドラインからプログラムに渡されるすべての引数は、文字列（`String`型）としてこの`args`という名前の配列に格納されます。  配列の要素は、コマンドラインでスペースで区切られた各文字列に対応します。  |

#### 標準出力

```java  showLineNumbers
        // メイン処理の開始をログに出力
        System.out.println("--- Javaプログラムを開始します ---");
```
*   `System.out.println()`: これは、Javaでコンソール（標準出力）にテキストを表示するための最も一般的な方法です。  

|項目　　　　|説明|
|---|---|
|`System`|Javaの標準ライブラリ（`java.lang`パッケージ）に含まれる最終クラスです。  システム関連の機能を提供します。  |
|`out`|`System`クラスの`public static final`なフィールドで、`PrintStream`型のオブジェクトです。  このオブジェクトが標準出力ストリームを表します。  |
|`println()`|`PrintStream`クラスのメソッドで、引数として渡された文字列を表示し、その後に改行（print line）を行います。  |

#### コマンドライン引数の処理

```java  showLineNumbers
        // コマンドライン引数があるかチェック
        if (args.length > 0) {
            // 引数がある場合、それらを結合して表示
            System.out.println("こんにちは、" + String.join(" と ", args) + "さん！");
            System.out.println("引数として以下の値が渡されました：");
            for (int i = 0; i < args.length; i++) {
                System.out.println("  args[" + i + "] = \"" + args[i] + "\"");
            }
        } else {
            // 引数がない場合、一般的なメッセージを表示
            System.out.println("こんにちは、Javaの世界へようこそ！");
            System.out.println("引数を指定して実行することもできます。例: java MyFirstJavaApp Alice Bob");
        }
```
*   `if (args.length > 0)`:  
`args`は`String`型の配列なので、`args.length`で配列の要素数（つまり、渡された引数の数）を取得できます。  
ここでは、引数が一つでも渡されたかどうかをチェックしています。  
*   `String.join(" と ", args)`:  
これはJava 8で導入された便利なメソッドで、配列やIterableの要素を、指定されたデリミタ（区切り文字）で結合して一つの文字列に変換します。  
ここでは、`args`配列の各要素（引数）を「 と 」で区切って結合しています。  
*   `for (int i = 0; i < args.length; i++) { ... }`:  
これは伝統的な`for`ループの構文で、配列の各要素をインデックス（`i`）を使って順番に処理します。  
*   `System.out.println(" args[" + i + "] = \"" + args[i] + "\"");`:  
ループ内で、各引数のインデックスとその値を表示しています。  
文字列と変数を`+`演算子で結合することで、一つの出力文字列を作成しています。  

### 4. コンパイルの手順

作成した`MyFirstJavaApp.java`ファイルを、`javac`コマンドを使ってバイトコードに変換します。  

1.  **ファイルの保存**: 上記のサンプルをコーディングし、`MyFirstJavaApp.java`という名前で保存します。   
保存場所は、ワークスペースを指定しましょう。  


2.  **コンパイルの実行**: ターミナルから以下のコマンドを実行します。  

    ```bash
    javac MyFirstJavaApp.java
    ```

    **詳細解説:**  
    `javac`コマンドが実行されると、内部的には以下のプロセスが行われます。  

    1.  **ソースファイルの読み込み**: `MyFirstJavaApp.java`ファイルを読み込みます。  
    2.  **字句解析 (Lexical Analysis)**: ソースコードを意味のある最小単位（トークン）に分割します。  例えば、`public`, `class`, `MyFirstJavaApp`, `{`, `;`などがトークンとして認識されます。  
    3.  **構文解析 (Syntax Analysis)**: トークンの並びがJavaの文法規則に合致しているかを確認し、抽象構文木（AST: Abstract Syntax Tree）を構築します。  これにより、コードの構造がツリー形式で表現されます。  
    4.  **意味解析 (Semantic Analysis)**: 構文解析されたコードが意味的に正しいかを確認します。  例えば、変数の型が正しいか、メソッド呼び出しの引数の数が合っているか、アクセス修飾子に違反がないかなどをチェックします。  もし問題があれば、ここでコンパイルエラーとして報告されます。  
    5.  **バイトコード生成 (Bytecode Generation)**: 意味解析をクリアしたコードを、JVMが理解できるバイトコード（`.class`ファイル）に変換します。  このバイトコードは、特定のCPUアーキテクチャに依存しない中間言語です。  

:::tip
**成功した場合**  
何もメッセージが表示されず、`MyFirstJavaApp.java`と同じディレクトリに`MyFirstJavaApp.class`というファイルが新しく生成されます。  
これがバイトコードファイルです。

**エラーが発生した場合**  
タイプミスや文法エラーがあると、エラーメッセージが表示されます。  
メッセージには、エラーが発生したファイル名、行番号、簡単な説明が含まれています。  
これらをよく読んで、`MyFirstJavaApp.java`ファイルを修正し、再度コンパイルしてください。
:::

    これで、OSに依存しないバイトコードが準備できました。  

### 5. 実行の手順

生成された`MyFirstJavaApp.class`ファイル（バイトコード）を、`java`コマンドを使ってJVM上で実行します。  

1.  **実行の実行（引数なし）**: コンパイルが成功し、`MyFirstJavaApp.class`があることを確認した状態で、以下のコマンドを実行します。  

    ```bash
    java MyFirstJavaApp
    ```

    **詳細解説:**  
    `java`コマンドが実行されると、内部的には以下のプロセスが行われます。  

    1.  **JVMの起動**: `java`コマンドは、まずJVM（Java Virtual Machine）を起動します。  
    2.  **クラスローディング**: JVMは、指定されたクラス名（この場合は`MyFirstJavaApp`）に対応する`.class`ファイルを、現在のディレクトリやCLASSPATHで指定された場所から探し出し、メモリにロードします。  この際、クラスのバイトコードが検証され、セキュリティ上の問題がないか、形式が正しいかなどが確認されます。  
    3.  **`main`メソッドの呼び出し**: ロードされたクラスの中から`public static void main(String[] args)`というシグネチャを持つメソッドを探し、そのメソッドを実行します。  
    4.  **バイトコードの実行とJITコンパイル**: JVMはロードされたバイトコードを直接実行することもできますが、パフォーマンス向上のため「Just-In-Time (JIT) コンパイラ」を使用します。  JITコンパイラは、実行時に頻繁に呼び出されるバイトコードのブロックを検出し、それをその場のOSおよびCPUに最適化されたネイティブな機械語にコンパイルします。  これにより、同じ処理が繰り返し実行される際に、コンパイル済みの高速な機械語が利用され、Javaアプリケーションの実行速度が向上します。  

:::tip
    *   `java`コマンドの後には、クラス名（ファイル名から`.java`や`.class`を除いた部分）を指定します。  
    `.class`拡張子は含めません。  
    *   JVMは、指定されたクラス名の`.class`ファイルを現在のディレクトリ（またはCLASSPATHで指定された場所）から探し、その中の`main`メソッドを実行します。  
:::

2.  **実行の実行（引数あり）**: コマンドライン引数を渡して実行してみましょう。  引数はクラス名の後にスペース区切りで指定します。  

    ```bash
    java MyFirstJavaApp Alice Bob Charlie
    ```

    **詳細解説:**  
    コマンドライン引数がどのようにJavaプログラムに渡されるかを、より具体的に見てみましょう。  

    | コマンドライン引数 | `String[] args`配列内の格納位置 | 値     |
    | :----------------- | :----------------------------- | :----- |
    | `Alice`            | `args[0]`                      | `"Alice"` |
    | `Bob`              | `args[1]`                      | `"Bob"`   |
    | `Charlie`          | `args[2]`                      | `"Charlie"` |

    このように、コマンドラインで`java クラス名 引数1 引数2 ...`と入力すると、`main`メソッドの`String[] args`配列に、スペースで区切られた各文字列が配列の要素として順番に格納されます。  
    プログラムは、この`args`配列にアクセスすることで、渡された引数を利用できます。  

### 6. Javaのコンパイルと実行における主要な用語

ここで、これまでのプロセスで登場した重要な用語を改めて整理します。  

*   **ソースコード (`.java`ファイル)**:  
    人間が理解しやすいように書かれたJavaのプログラムコードです。  
    プログラマはこれをテキストエディタで作成します。  
    Java言語の文法に従って記述されます。  

*   **コンパイラ (`javac`)**:  
    JDKに含まれるツールの一つで、Javaのソースコードをバイトコードに変換する役割を担います。  
    ソースコードの文法チェックも行い、誤りがあればエラーを報告します。  
    `javac`は、Java言語仕様に厳密に従ってソースコードを解析し、JVMが効率的に実行できる形式のバイトコードを生成します。  

*   **バイトコード (`.class`ファイル)**:  
    コンパイルされたJavaのプログラムの形式です。  
    これは特定のCPUの機械語ではなく、JVMが理解できる中間言語です。  
    プラットフォームに依存しないため、「一度書けばどこでも動く」の基盤となります。  
    バイトコードは、JVMのスタックベースの命令セット（命令とオペランドからなる）で構成されます。  

*   **JVM (Java Virtual Machine - Java仮想マシン)**:  
    バイトコードを実行するための仮想的なコンピュータです。  
    各OSに対応したJVMが提供されており、同じバイトコードをそれぞれのOS上で実行可能にします。  
    JVMは、バイトコードを実行時にそのOSの機械語に変換する役割も持っています（JITコンパイル）。  
    JITコンパイラは、プログラムの実行中に頻繁に実行されるコード（ホットスポット）を特定し、その部分をOS固有の機械語に変換することで、ネイティブアプリケーションに近い実行速度を実現します。  

*   **JRE (Java Runtime Environment - Java実行環境)**:  
    Javaアプリケーションを実行するために必要なソフトウェア一式です。  
    JVMと、プログラムが利用する基本的なライブラリ（API）が含まれます。  
    かつてはJDKとは別に配布されていましたが、Java 9以降はJDKに含まれる形で提供されることが多くなりました。  

*   **JDK (Java Development Kit - Java開発キット)**:  
    Javaアプリケーションの開発と実行に必要なツール一式です。  
    JREに加えて、コンパイラ(`javac`)、デバッガ、ドキュメンテーションツールなどが含まれます。  
    Java開発者はJDKをインストールします。  

**JDK, JRE, JVMの関連性:**  

| 用語  | 略称 | 役割                                               | 含まれるもの                                              |
| :---- | :--- | :------------------------------------------------- | :-------------------------------------------------------- |
| Java仮想マシン | JVM  | Javaバイトコードを実行する仮想的なコンピュータ。  各OSに最適化されたバイトコード実行環境を提供。 | なし (OS固有の実装)                                       |
| Java実行環境 | JRE  | Javaアプリケーションを実行するために必要な最小限のセット。 | JVM + 標準ライブラリ (Java API)                           |
| Java開発キット | JDK  | Javaアプリケーションの開発と実行に必要なフルセット。 | JRE + 開発ツール (`javac`, `jar`, `javadoc`, デバッガなど) |

つまり、JDKはJava開発者向けのものであり、JREはJavaアプリケーションを単に実行したいユーザー向けのものでした。  
そして、JVMはそのどちらにも含まれる、バイトコード実行の中核をなす部分です。  

### 7. IDE（統合開発環境）利用時の注意点

Eclipseなどの統合開発環境（IDE）を使用する場合、コンパイルや実行のプロセスはIDEが自動的に行ってくれます。  
通常は、`実行`ボタンをクリックするだけで、IDEが内部で`javac`を実行してコンパイルし、`java`を実行してプログラムを起動します。  

しかし、裏では今回手動で行った`javac`と`java`のコマンドが実行されており、これらの基本的なメカニズムを理解することは、トラブルシューティングやより複雑なプロジェクト管理において非常に重要です。  
例えば、依存関係が複雑な大規模なプロジェクトでは、MavenやGradleといったビルドツールがこれらのコンパイルやパッケージングのプロセスを自動化しますが、それらのツールも結局は内部で`javac`や`java`を呼び出しています。  

この基礎を理解することで、IDEが提供する抽象化の裏側で何が起きているのかを把握し、問題発生時の原因究明や、より高度な開発手法への理解を深めることができます。  


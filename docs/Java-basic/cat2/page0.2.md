# コンパイルエラー

Javaでプログラムを書く際、コードに間違いがあると、実行する前にコンパイラが「コンパイルエラー」として教えてくれます。  
このエラーメッセージを正しく読み解くことは、プログラミング学習において非常に重要なスキルです。  

ここでは、よくあるコンパイルエラーの例を見ながら、その読み方と修正方法を学びましょう。  

### コンパイルの基本的な流れ

Javaのコード（`.java`ファイル）は、直接コンピューターが理解できる形式ではありません。  
`javac`コマンド（Javaコンパイラ）を使って、コンピューターが理解できる形式（バイトコード、`.class`ファイル）に変換（コンパイル）する必要があります。  

例: `HelloWorld.java`というファイルがある場合、ターミナルで以下のように実行します。

```bash
javac HelloWorld.java
```

もしコードに間違いがなければ、`.class`ファイルが生成されます。  
間違いがあれば、エラーメッセージが表示されます。  

### エラーメッセージの読み方：共通のヒント

コンパイラが出力するエラーメッセージには、共通して以下の情報が含まれています。

1.  **ファイル名と行番号**  
    `ファイル名:行番号: error:` の形式で、エラーが発生した場所を示します。 最も重要な情報です。  
2.  **エラーの種類**  
    具体的にどのような問題が発生しているかを示すキーワードです。  
3.  **詳細メッセージ**  
    エラーの種類を補足する具体的な説明です。  
4.  **コードの抜粋とポインタ (`^`)**  
    エラーが発生した行のコードが表示され、`^`（キャレット）記号が問題の箇所を指し示します。  

:::info
### エラーは上から順に修正する
1つのエラーが、その後の複数のエラーを引き起こすことがあります。  
そのため、表示されたエラーメッセージは上から1つずつ、順番に修正していくのが鉄則です。  
:::

### よくあるコンパイルエラーと読み方

ここから、具体的なサンプルコードと、それに対応するコンパイルエラー、そしてその読み方を解説します。  

---

#### エラー1: セミコロン忘れ (`;` Missing Semicolon)

Javaの多くの文の終わりにはセミコロン（`;`）が必要です。  
これは、プログラムの各命令（文）の区切りを示す役割を果たします。  

**エラーのあるコード (`ErrorSample1.java`):**

```java
public class ErrorSample1 {
    public static void main(String[] args) {
        System.out.println("Hello World") // <-- ここにセミコロンがありません！
        System.out.println("コンパイルエラーの例1");
    }
}
```

**`javac ErrorSample1.java` の出力例:**

```
ErrorSample1.java:4: error: ';' expected
        System.out.println("Hello World")
                                         ^
1 error
```

**エラーメッセージの読み解き:**

| 情報項目         | 実際のメッセージ例                           | 意味とポイント                                                                                                                                              |
| :--------------- | :------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------- |
| ファイル名と行番号 | `ErrorSample1.java:4: error:`                | `ErrorSample1.java`ファイルの**4行目**でエラーが発生しています。                                                                                      |
| エラーの種類     | `';' expected`                               | 「セミコロンが期待されています」という意味です。 コンパイラが、あるべき場所でセミコロンを見つけられなかったことを示します。                            |
| コードの抜粋     | `System.out.println("Hello World")`          | 問題の行のコードです。 この行のどこかにセミコロンが必要だとコンパイラが判断しています。                                                             |
| ポインタ (`^`)   | `                                         ^` | `System.out.println("Hello World")` の**直後**を指しています。 これは、この位置にセミコロンが足りないことを明確に示唆しています。                      |

**このエラーの原因:**  
Javaでは、ほとんどの文（`System.out.println`のような命令文や変数の宣言など）の終わりにセミコロンが必要です。  
これは、日本語の文章で句点（。）を打つのに似ています。  
セミコロンがないと、コンパイラはどこまでが一つの文なのかを判断できません。  
上記の例では、4行目の `System.out.println("Hello World")` の後にセミコロンがないため、コンパイラは次の行の `System.out.println("コンパイルエラーの例1");` を前の行の続きだと誤解しようとします。  
しかし、構文的に続きにはならないため、「セミコロンが足りない」というエラーを出力します。  

**修正方法:**  
4行目の `System.out.println("Hello World")` の末尾に `;` を追加します。

```java
public class ErrorSample1 {
    public static void main(String[] args) {
        System.out.println("Hello World"); // 修正済
        System.out.println("コンパイルエラーの例1");
    }
}
```

---

#### エラー2: 変数未宣言 (Cannot Find Symbol - Variable)

使用しようとしている変数（データを一時的に保存する箱の名前）が、プログラム内のどこにも宣言（定義）されていない場合に発生するエラーです。  
Javaでは、変数を使う前に、その変数の「型」（どのような種類のデータを格納するか）と「名前」を宣言する必要があります。  

**エラーのあるコード (`ErrorSample2.java`):**

```java
public class ErrorSample2 {
    public static void main(String[] args) {
        // messageという名前の変数をここで宣言していません
        System.out.println(message); // <-- 未宣言の変数を使おうとしている
    }
}
```

**`javac ErrorSample2.java` の出力例:**

```
ErrorSample2.java:4: error: cannot find symbol
        System.out.println(message);
                           ^
  symbol:   variable message
  location: class ErrorSample2
1 error
```

**エラーメッセージの読み解き:**

| 情報項目         | 実際のメッセージ例                           | 意味とポイント                                                                                                                                                                |
| :--------------- | :------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ファイル名と行番号 | `ErrorSample2.java:4: error:`                | `ErrorSample2.java`ファイルの**4行目**でエラーが発生しています。                                                                                                      |
| エラーの種類     | `cannot find symbol`                         | 「シンボルを見つけられません」という意味です。 ここでいう「シンボル」とは、変数名、メソッド名、クラス名など、コード内で使用される特定の名前を指します。            |
| コードの抜粋     | `System.out.println(message);`               | 問題の行のコードです。                                                                                                                                                |
| ポインタ (`^`)   | `                           ^`                | `message` の部分を指しています。                                                                                                                                      |
| 詳細メッセージ   | `symbol: variable message`<br />`location: class ErrorSample2` | 具体的に見つからなかったシンボルが「`message`という名前の変数」であることを示しています。 また、そのシンボルが `ErrorSample2` クラス内で見つからなかったことも示しています。 |

**このエラーの原因:**  
Javaは、非常に厳格なルールを持つ言語です。  
変数を使用する前に、コンパイラに対してその変数がどのような型（例: 整数なら`int`、文字列なら`String`など）で、どのような名前であるかをあらかじめ知らせる「宣言」が必要です。 宣言がない変数をコード中でいきなり使おうとすると、コンパイラは「そのような名前の変数を見たことがない」と判断し、`cannot find symbol`エラーを返します。  
これは、コンパイラがコードを理解し、メモリを適切に確保するために必要な情報だからです。  

**修正方法:**  
`message`変数を使う前に、その型を指定して宣言し、必要であれば初期化（初期値を代入）します。

```java
public class ErrorSample2 {
    public static void main(String[] args) {
        String message = "変数`message`を宣言しました！"; // 修正済: 変数を宣言し、初期化
        System.out.println(message);
    }
}
```

---

#### エラー3: 型の不一致 (Incompatible Types)

変数に、その型と互換性のない値（データ）を代入しようとした場合や、メソッドに期待される型と異なる型の引数を渡そうとした場合に発生するエラーです。  
Javaは「静的型付け言語」であり、変数の型はコンパイル時に厳密にチェックされます。  

**エラーのあるコード (`ErrorSample3.java`):**

```java
public class ErrorSample3 {
    public static void main(String[] args) {
        int number = "これは文字列です"; // <-- int型変数に文字列を代入しようとしている
        System.out.println(number);
    }
}
```

**`javac ErrorSample3.java` の出力例:**

```
ErrorSample3.java:4: error: incompatible types: String cannot be converted to int
        int number = "これは文字列です";
                     ^
1 error
```

**エラーメッセージの読み解き:**

| 情報項目         | 実際のメッセージ例                           | 意味とポイント                                                                                                                                                                  |
| :--------------- | :------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ファイル名と行番号 | `ErrorSample3.java:4: error:`                | `ErrorSample3.java`ファイルの**4行目**でエラーが発生しています。                                                                                                      |
| エラーの種類     | `incompatible types`                         | 「互換性のない型」という意味です。 変数に代入しようとしているデータの型と、変数が宣言されている型が合わないことを示します。                                           |
| 詳細メッセージ   | `String cannot be converted to int`          | **「`String`型を`int`型に変換できません」**という具体的な理由が示されています。 これは、文字列（`"..."`で囲まれたもの）は整数（`int`）として扱えないという意味です。 |
| コードの抜粋     | `int number = "これは文字列です";`            | 問題の行のコードです。                                                                                                                                                |
| ポインタ (`^`)   | `                     ^`                      | `"これは文字列です"` の部分を指しています。 この値の型（`String`）が、代入先の変数 `number` の型（`int`）と互換性がないことが問題であることを示しています。             |

**このエラーの原因:**  
Javaは、変数が格納できるデータの種類を「型」として事前に定めます。  
例えば、`int`型は整数値のみを格納でき、`String`型は文字列のみを格納できます。  
これは、データがメモリ上でどのように扱われるか、またどのような操作が許されるかを明確にするためです。  
上記のコードでは、`int`型として宣言された変数 `number` に、文字列リテラル（`"..."`）である`String`型の値を代入しようとしています。  
コンパイラは、`String`型の値を`int`型として扱う方法を知らない（自動的に変換できない）ため、このエラーを出力します。  

**修正方法:**  
`int`型の変数には整数を代入します。 文字列を扱いたい場合は`String`型を使います。

```java
public class ErrorSample3 {
    public static void main(String[] args) {
        int number = 123; // 修正済: int型変数には整数を代入
        System.out.println(number);

        // あるいは、文字列を扱いたい場合はString型の変数として宣言する
        // String text = "これは文字列です";
        // System.out.println(text);
    }
}
```

---

#### エラー4: メソッド名の誤り、または引数の不一致 (Cannot Find Symbol - Method / No Suitable Method)

存在しないメソッド名を呼び出そうとしたり、メソッドが期待する引数（渡す値）の数や型が異なったりする場合に発生します。  
「メソッドシグネチャ」（メソッド名と引数の型・数の組み合わせ）が一致するメソッドが見つからない場合に発生するエラーです。  

**エラーのあるコード (`ErrorSample4.java`):**

```java
public class ErrorSample4 {
    public static void main(String[] args) {
        // System.out.println の 'n' が一つ多い（typo: タイプミス）
        System.out.printlnn("間違ったメソッド名"); // <-- メソッド名が間違っている
    }
}
```

**`javac ErrorSample4.java` の出力例:**

```
ErrorSample4.java:4: error: cannot find symbol
        System.out.printlnn("間違ったメソッド名");
              ^
  symbol:   method printlnn(String)
  location: class java.io.PrintStream
1 error
```

**エラーメッセージの読み解き:**

| 情報項目         | 実際のメッセージ例                           | 意味とポイント                                                                                                                                                                                              |
| :--------------- | :------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ファイル名と行番号 | `ErrorSample4.java:4: error:`                | `ErrorSample4.java`ファイルの**4行目**でエラーが発生しています。                                                                                                                      |
| エラーの種類     | `cannot find symbol`                         | 再び「シンボルを見つけられません」です。 この場合、シンボルは「メソッド」を指します。                                                                                                 |
| コードの抜粋     | `System.out.printlnn("間違ったメソッド名");`   | 問題の行のコードです。                                                                                                                                                                |
| ポインタ (`^`)   | `              ^`                             | `printlnn` の部分を指しています。 このメソッド名に問題があることを示唆しています。                                                                                                  |
| 詳細メッセージ   | `symbol: method printlnn(String)`<br />`location: class java.io.PrintStream` | 見つからなかったシンボルが「`String`型を引数に取る`printlnn`という名前のメソッド」であることを示しています。 そのメソッドが `java.io.PrintStream` クラス（`System.out`の型）で見つからなかったことも示しています。 |

**このエラーの原因:**  
Javaでは、特定の操作を行うための「メソッド」が多数提供されています。  
これらのメソッドは、それぞれ決められた名前と、受け取れる引数（渡す値）の型や数の組み合わせ（メソッドシグネチャ）を持っています。  
`System.out.println`は、文字列や数値を画面に出力するための非常に一般的なメソッドですが、`printlnn`という名前のメソッドはJavaの標準ライブラリには存在しません。  
コンパイラは、コード内で呼び出されている`printlnn`という名前のメソッドと、引数として渡されている`String`型の値の組み合わせに一致するメソッドを、`System.out`が属する`PrintStream`クラス内で探し、見つからなかったためこのエラーを出力します。  

**修正方法:**  
正しいメソッド名（`println`）に修正します。

```java
public class ErrorSample4 {
    public static void main(String[] args) {
        System.out.println("正しいメソッド名を使いました！"); // 修正済: 'println' に修正
    }
}
```

---

#### エラー5: 括弧の不一致 (Missing Brace / Unclosed Literal)

`{`（開き波括弧）や `}`（閉じ波括弧）、`(`（開き丸括弧）や `)`（閉じ丸括弧）、`"`（引用符）などが対応していない場合に発生します。  
特に波括弧の閉じ忘れは頻繁に起こります。  
Javaのコードは、これらの括弧によって構造が定義されているため、対応する括弧が欠けているとコンパイラはコードの構造を正しく理解できません。  

**エラーのあるコード (`ErrorSample5.java`):**

```java
public class ErrorSample5 {
    public static void main(String[] args) {
        System.out.println("閉じ括弧が足りません");
    } // <-- mainメソッドの閉じ括弧はあるが、クラスの閉じ括弧が足りない
// } がない
```

**`javac ErrorSample5.java` の出力例:**

```
ErrorSample5.java:5: error: reached end of file while parsing
}
^
1 error
```

**エラーメッセージの読み解き:**

| 情報項目         | 実際のメッセージ例                           | 意味とポイント                                                                                                                                                                |
| :--------------- | :------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ファイル名と行番号 | `ErrorSample5.java:5: error:`                | `ErrorSample5.java`ファイルの**5行目**（この場合、ファイルの末尾）でエラーが発生しています。                                                                          |
| エラーの種類     | `reached end of file while parsing`          | **「ファイルの解析中にファイルの終わりに達しました」**という意味です。                                                                                                  |
| コードの抜粋     | `}`                                          | エラーが発生した場所付近のコード。この場合、ファイル終端の直前にある最後の波括弧が示されています。                                                                    |
| ポインタ (`^`)   | `^`                                          | 最後の行のさらに外側（ファイルの終端）を指していることが多いです。                                                                                                      |
| 詳細メッセージ   | (このエラーでは種類が詳細メッセージを兼ねる) | コンパイラがまだ処理を終えていないのに、コードが途中で終わってしまったことを示します。 通常、どこかの `{`（開き括弧）に対応する `}`（閉じ括弧）が足りない場合に発生します。 |

**このエラーの原因:**  
Javaのプログラムは、クラスやメソッドといった「ブロック」によって構成されており、これらのブロックは `{` と `}` で囲まれます。  
例えば、`public class ErrorSample5 { ... }` のように、クラス全体も波括弧で囲まれています。  
プログラムのどこかで開き括弧があるのに対応する閉じ括弧がないと、コンパイラは「このブロックはどこで終わるんだ？」と混乱します。  
`reached end of file while parsing`というメッセージは、コンパイラがファイルの最後まで読み込んでも、まだ「閉じられていないブロックがある」と判断したときに表示されます。  
最も外側のクラスの閉じ括弧が足りない場合によく見られます。  

**修正方法:**  
クラス定義の最後に `}` を追加します。

```java
public class ErrorSample5 {
    public static void main(String[] args) {
        System.out.println("閉じ括弧を追加しました！");
    }
} // 修正済: クラスの閉じ括弧を追加
```

---

### まとめ

コンパイルエラーは、あなたのコードの「文法ミス」や「論理的な矛盾」を教えてくれる先生のようなものです。  
エラーメッセージは、プログラミング学習における重要な情報源です。  

*   **焦らない**  
    エラーメッセージは怖くありません。 落ち着いて読みましょう。  
*   **行番号を見る**  
    まずエラーが発生したファイルと行番号を確認し、その行のコードを見直しましょう。  
*   **エラーメッセージを読む**  
    何が問題なのか、キーワードと詳細メッセージから理解を試みましょう。  
*   **`^` (キャレット) をヒントにする**  
    `^` が指す場所が直接的な原因とは限りませんが、その周辺に問題がある可能性が高いです。  
*   **上から順番に直す**  
    最初の1つのエラーを直すだけで、後続のたくさんのエラーが消えることがあります。  

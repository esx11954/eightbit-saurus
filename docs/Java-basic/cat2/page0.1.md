# 変数

### はじめに：変数とは

プログラミングにおける「変数（Variable）」とは、**データ（値）を一時的に記憶しておくための箱**のようなものです。  
この箱には名前（変数名）が付けられており、プログラムの実行中にその中身（値）を自由に変更したり、取り出したりすることができます。  
変数は英語の "variable" が語源で、「変化できるもの」「移ろいやすいもの」という意味を持ち、その名の通り、格納する値をプログラムの途中で変更できるのが最大の特徴です。  

なぜ変数が必要なのでしょうか？  

*   **データの保持**  
    計算結果やユーザーからの入力など、プログラムが扱う様々なデータを一時的に保存するためです。  
    例えば、ユーザーが入力した名前や年齢をプログラムが記憶し、後で利用するために変数に格納します。  
*   **再利用性**  
    同じデータを何度も利用する場合、変数に入れておけば、その変数名を指定するだけで簡単にアクセスできます。  
    例えば、円周率を何度も計算に使う場合、`PI`という変数に格納しておけば、何度も`3.14159`と書く必要がなくなります。  
*   **柔軟性**  
    プログラムの実行中に値を変えることができるため、より柔軟な処理を記述できます。  
    例えば、ゲームのスコアのように、状況に応じて変化する値を扱う際に、変数は不可欠です。  

それでは、具体的なJavaコードを見ていきましょう。

### サンプルコード: `VariableUnderstanding.java`

```java showLineNumbers
public class VariableUnderstanding {

    public static void main(String[] args) {

        System.out.println("--- 1. 変数の宣言と初期化 ---");
        // 変数の宣言: 「箱を用意する」
        // データ型 変数名; の形式で記述します。
        int age; // int型のageという名前の変数を宣言

        // 変数の初期化（代入）: 「箱に値を最初に入れる」
        // 変数名 = 値; の形式で記述します。
        age = 30; // age変数に30という値を代入（初期化）
        System.out.println("私の年齢: " + age + "歳");

        // 変数の宣言と初期化を同時に行うことも可能です。
        // データ型 変数名 = 値; の形式で記述します。
        String name = "田中"; // String型のname変数を宣言し、「田中」で初期化
        System.out.println("私の名前: " + name);

        // ... （以降のコードは後続の解説に続く）
    }
}
```

### 解説

上記のコードを実行すると、各セクションの出力がコンソールに表示されます。  
それぞれのセクションについて、以下でさらに詳しく解説します。

---

### 1. 変数の宣言と初期化

変数は、使用する前に必ず「宣言」と「初期化」を行う必要があります。  
Javaでは、未初期化の変数を使おうとするとコンパイルエラーになる可能性があるため、安全性が高まります。  

```java showLineNumbers
        // 変数の宣言: 「箱を用意する」
        // データ型 変数名; の形式で記述します。
        int age; // int型のageという名前の変数を宣言

        // 変数の初期化（代入）: 「箱に値を最初に入れる」
        // 変数名 = 値; の形式で記述します。
        age = 30; // age変数に30という値を代入（初期化）
        System.out.println("私の年齢: " + age + "歳");

        // 変数の宣言と初期化を同時に行うことも可能です。
        // データ型 変数名 = 値; の形式で記述します。
        String name = "田中"; // String型のname変数を宣言し、「田中」で初期化
        System.out.println("私の名前: " + name);
```

*   **宣言 (Declaration)**  
    変数を宣言するということは、「このプログラムで、こういう種類のデータを保存するための、この名前の箱を使いますよ」とJavaに伝えることです。  
    書式は「`データ型 変数名;`」となります。  
    例: `int age;` は「`age`という名前で整数(`int`)を入れられる箱を用意します」という意味です。  
    この段階では、箱は用意されますが、中身は空っぽの状態（厳密にはプリミティブ型の場合、そのデータ型のデフォルト値が設定されることもありますが、明示的な初期化が推奨されます）です。  
    メモリ上では、変数のデータ型に応じた大きさの領域が確保され、その領域に`age`という名前が付けられます。  

*   **初期化 (Initialization)**  
    宣言した変数に、**初めて**値を代入することです。  
    書式は「`変数名 = 値;`」となります。  
    例: `age = 30;` は「`age`という箱に`30`という値を入れてください」という意味です。  

    :::caution
    ここで使われている`=`記号は、数学の「等しい」という意味ではなく、  
    「右辺の値を左辺の変数に**代入する**」という意味の**代入演算子**です。  
    :::

*   **同時宣言・初期化**  
    変数の宣言と初期化は、「`データ型 変数名 = 値;`」のように、一行で同時に行うことが一般的です。  
    例: `String name = "田中";` は「`name`という名前で文字列(`String`)を入れられる箱を用意し、そこに最初から「田中」という値を入れてください」という意味になります。  
    この形式はコードを簡潔にし、可読性を高めます。  

---

### 2. 様々なデータ型

Javaには、格納するデータの種類に応じてさまざまな「データ型」があります。  
適切なデータ型を選択することは、メモリの効率的な使用や、意図しないエラーを防ぐ上で非常に重要です。  
大きく分けて「プリミティブ型（基本データ型）」と「参照型」の2種類があります。  

```java showLineNumbers
        System.out.println("\n--- 2. 様々なデータ型 ---");
        // Javaには、格納できるデータの種類によって様々な「データ型」があります。
        // ここでは代表的なプリミティブ型と参照型（String）を紹介します。

        // 整数型: 小数点を含まない数値を扱います。
        // byte, short, int, long の順で扱える値の範囲が広くなります。
        byte b = 10;          // -128から127まで (1バイト)
        short s = 1000;       // 約-3万から3万まで (2バイト)
        int i = 100000;       // 約-20億から20億まで (4バイト) 最もよく使われます
        long l = 10000000000L; // 約-900京から900京まで (8バイト) 値の末尾にLまたはlを付けます
        System.out.println("byte型: " + b + ", short型: " + s + ", int型: " + i + ", long型: " + l);

        // 浮動小数点型: 小数点を含む数値を扱います。
        // float, double があります。doubleの方が精度が高いです。
        float f = 123.45f;    // 値の末尾にfまたはFを付けます (4バイト)
        double d = 1234.56;   // デフォルトはこちらが使われます (8バイト) (fを付けなければdoubleとみなされる)
        System.out.println("float型: " + f + ", double型: " + d);

        // 真偽値型: 真(true)か偽(false)を扱います。
        boolean isLearningJava = true; // (通常1バイト)
        boolean hasFinished = false;
        System.out.println("Java学習中？: " + isLearningJava + ", 終了した？: " + hasFinished);

        // 文字型: 一文字を扱います。シングルクォーテーション(')で囲みます。
        char initial = 'J'; // (2バイト) Unicode文字を扱える
        System.out.println("イニシャル: " + initial);

        // 参照型: クラスのインスタンスを扱います。Stringは特に頻繁に使われます。
        // 厳密にはプリミティブ型ではありませんが、変数として非常に重要です。
        String message = "Java変数の学習は楽しい！"; // ダブルクォーテーション("")で囲みます。
        System.out.println("メッセージ: " + message);
```

Javaで良く使用されるデータ型とその特徴は以下の通りです。  

| データ型       | 種類         | 説明                                                              | 例                      | 注意点                                                     |
| :------------- | :----------- | :---------------------------------------------------------------- | :---------------------- | :--------------------------------------------------------- |
| `int`          | プリミティブ | 整数値を格納します。  一般的に最もよく使われる整数型です。        | `100`, `-5`             |                                                            |
| `long`         | プリミティブ | `int`よりも大きな整数値を格納できます。                           | `1234567890123L`        | 数値の末尾に`L`または`l`を付けます（`L`推奨）。            |
| `double`       | プリミティブ | 小数を含む数（浮動小数点数）を格納します。  `float`より精度が高いです。 | `99.99`, `3.14`         | 小数を扱う際の標準的な型です。                             |
| `float`        | プリミティブ | `double`より精度の低い小数を含む数を格納します。                  | `25.5f`                 | 数値の末尾に`f`または`F`を付けます。  通常は`double`を使用。 |
| `char`         | プリミティブ | 1文字を格納します。  シングルクォート（`'`）で囲みます。          | `'A'`, `'z'`, `'1'`     | 文字コード（Unicode）に基づいて処理されます。              |
| `boolean`      | プリミティブ | 真偽値（`true`または`false`）を格納します。                        | `true`, `false`         | 条件判断によく使われます。                                 |
| `String`       | 参照型       | 複数の文字の並び（文字列）を格納します。  ダブルクォート（`"`）で囲みます。 | `"Hello"`, `"Java"`     | プリミティブ型ではなく、クラス（参照型）です。           |


:::info
*   **`L` と `f` のサフィックス**:  
    Javaでは、整数リテラル（コードに直接書かれた数値）はデフォルトで`int`型、浮動小数点数リテラルはデフォルトで`double`型として扱われます。  
    そのため、`long`型の値や`float`型の値を明示的に示すために、それぞれ`L`（または`l`）や`f`（または`F`）を末尾に付ける必要があります。  

*   **`char` と `String` のクォート**:  
    `char`型は1文字を表すため、シングルクォート（`'`）で囲みます。  
    `String`型は複数の文字からなる文字列を表すため、ダブルクォート（`"`）で囲みます。  
:::

#### 2.1. プリミティブ型（基本データ型）

プリミティブ型は、数値（整数・小数）、真偽値、文字といった基本的な単一の値を**直接**メモリに格納します。  
**変数が値そのものを保持する**ため、非常に高速に処理できます。  

#### 2.2. 参照型

参照型は、オブジェクト（複雑なデータ構造）や配列を扱います。  
プリミティブ型とは異なり、変数が**直接値を持つのではなく**、オブジェクトが格納されているメモリ上の「場所」つまり**アドレス-参照**を保持します。  
実際のデータはヒープメモリと呼ばれる領域に格納され、変数はそのデータへの「ポインタ」のような役割を果たします。  
`String`、配列、そして自作する全てのクラスは参照型です。  

:::info
#### **String型**  
    文字列を扱うための参照型です。  
    ダブルクォーテーション (`"`) で囲みます（例: `"Java変数の学習は楽しい！"`）。  
    `String`はJavaで非常に頻繁に利用されるクラスであり、Javaが提供する多くの機能（文字列連結、検索、置換など）を利用できます。  
    厳密にはプリミティブ型ではありませんが、その利用頻度の高さから、しばしばプリミティブ型と並んで基本中の基本として紹介されます。  
    `String`オブジェクトは一度作成されると変更できない「immutable（不変）」という特性を持っています。  
:::

#### 2.3. 変数の初期値
変数を宣言し、初期化をしていない状態ではそれぞれのデータ型毎に初期値が設定されます。

**各データ型の初期値の比較:**  

| データ型 | デフォルト値 | 説明 |
| :------- | :----------- | :--- |
| `byte`, `short`, `int`, `long` | `0` | 整数型の数値ゼロ。 |
| `float`, `double` | `0.0` | 浮動小数点型の数値ゼロ。 |
| `char` | `\u0000` | Unicodeのヌル文字。  画面に表示されない文字です。 |
| `boolean` | `false` | 論理値の`false`。 |
| 参照型 (例: `String`, `Object`, 自作クラス) | `null` | どのオブジェクトも参照していない状態。  「何も指していない」ことを意味します。 |


---

### 3. 変数の値の変更（再代入）

変数の最も基本的な機能の一つが、その値を変更できることです。  
「変数」という名前の通り、中に格納する値が「変化」することが可能です。  
一度初期化した後でも、`変数名 = 新しい値;`という形で何度でも値を上書きできます。  
これは、メモリ上の変数が占める領域に、新しい値が書き込まれることを意味します。  

```java showLineNumbers
        System.out.println("\n--- 3. 変数の値の変更（再代入） ---");
        // 変数に一度値を代入した後でも、別の値を再代入することができます。
        int score = 80;
        System.out.println("初期スコア: " + score);

        score = 95; // score変数に新しい値95を再代入
        System.out.println("更新後のスコア: " + score);

        // 変数同士の代入も可能です。
        int currentScore = score; // scoreの値をcurrentScoreに代入
        System.out.println("現在のスコア: " + currentScore);
```

*   **再代入の例**:  
    `int score = 80;`で`score`という箱に`80`が入ります。  
    その後、`score = 95;`とすると、`score`の箱の中身は`80`から`95`に上書きされます。  
    元の値`80`は失われます。  

*   **変数同士の代入**:  
    `int currentScore = score;`のように、ある変数の値を別の変数に代入することもできます。  
    この場合、`score`が持っている値（この時点では`95`）がコピーされ、`currentScore`という新しい変数に格納されます。  
    `score`変数の中身は変更されません。  

---

### 4. 変数の命名規則と慣習

変数はプログラムの可読性に大きく影響するため、適切な名前を付けることが非常に重要です。  
命名規則には、Javaの文法として**必須のルール**と、より良いコードを書くための**推奨される慣習**があります。  

```java showLineNumbers
        System.out.println("\n--- 4. 変数の命名規則と慣習 ---");
        // 変数名にはルールと、可読性を高めるための慣習があります。

        // 【ルール】
        // 1. 英数字、アンダースコア(_)、$のみが使える。
        // 2. 数字で始まることはできない。
        // 3. Javaの予約語（例: int, public, classなど）は使えない。
        // 4. 大文字と小文字は区別される (ageとAgeは別の変数)。

        // 良い例（慣習に則ったもの）
        int studentCount = 15; // 複数の単語は最初の単語は小文字、それ以降は大文字で始める (camelCase)
        String userFirstName = "太郎";
        boolean isActiveUser = true;

        System.out.println("学生数: " + studentCount + ", ユーザー名: " + userFirstName + ", アクティブユーザー: " + isActiveUser);

        // 悪い例（コメントアウトしてあります）
        // int 1stStudent = 5;      // 数字から始まるためNG
        // int public = 10;         // 予約語のためNG
        // int my-variable = 20;    // ハイフンは使えないためNG
        // int 学籍番号 = 100;      // 日本語は避けるべき (ルール上は可能だが非推奨)
```

#### 4.1. 【命名ルール】（Javaの文法として必須）

これらのルールに違反すると、コンパイルエラーとなり、プログラムは実行できません。  

1.  **使える文字**:  
    変数名に使用できるのは、英字（`a-z`, `A-Z`）、数字（`0-9`）、アンダースコア (`_`)、ドル記号 (`$`) のみです。  
    スペースやハイフン（`-`）は使えません。  
    例: `my_variable`はOK、`my-variable`はNG。  
    `$`は自動生成されたコードなどで使われることがありますが、通常の手書きコードではあまり推奨されません。  

2.  **最初の文字**:  
    変数名は数字で始めることはできません。  
    例: `1stStudent`はNG、`student1`はOK。  

3.  **予約語**:  
    `int`, `public`, `class`, `if`, `else`, `while`, `for`, `return`, `void`など、Javaの文法で特別な意味を持つキーワード（予約語）は変数名として使えません。  

4.  **大文字と小文字の区別**:  
    Javaは**大文字と小文字を厳密に区別します**。  
    `age`と`Age`は、Javaにとっては全く別の変数として扱われます。  
    この特性は、プログラミング言語によって異なるため注意が必要です。  

#### 4.2. 【命名慣習】（可読性を高めるための推奨ルール）

これらの慣習は文法的に必須ではありませんが、これらに従うことで、他の開発者（または未来の自分）がコードを理解しやすくなります。  
これは、保守性やチーム開発において非常に重要です。  

*   **`camelCase` (キャメルケース)**:  
    変数名が複数の単語から構成される場合、最初の単語は小文字で始め、それ以降の単語の先頭は大文字にします。  
    まるでラクダのコブのように見えることから「キャメルケース」と呼ばれます。  
    例: `studentCount`, `userFirstName`, `isActiveUser`。  
    これがJavaにおける変数名の標準的な慣習です。  

*   **意味のある名前**:  
    変数が何を表しているのか、その役割や目的が明確にわかるような名前を付けましょう。  
    例えば、単に`x`や`tmp`とするのではなく、`age`, `totalScore`, `isValidInput`のように具体的にします。  
    短い名前は入力が楽ですが、可読性を損ねます。  

*   **英数字のみ**:  
    ルール上は日本語の変数名も可能ですが、環境依存の問題や、多言語での開発との相性を考慮し、**英数字のみを使用することが強く推奨されます**。  
    ほとんどのJavaプロジェクトでは日本語の変数名は使われません。  

---

### 5. 定数（`final`キーワード）

`final`キーワードを付けて変数を宣言すると、その値は一度初期化したら変更できなくなります。  
これを「定数（Constant）」と呼びます。  
定数を使用することで、プログラムの堅牢性（バグの発生しにくさ）を高めることができます。  

```java showLineNumbers
        System.out.println("\n--- 5. 定数（finalキーワード） ---");
        // `final`キーワードを付けて変数を宣言すると、その値は一度初期化したら変更できなくなります。
        // これを「定数」と呼びます。定数名は慣習としてすべて大文字で記述し、単語間はアンダースコアで繋ぎます。
        final double PI = 3.14159;
        final String APP_VERSION = "1.0.0";

        System.out.println("円周率: " + PI);
        System.out.println("アプリケーションバージョン: " + APP_VERSION);

        // PI = 3.0; // ← これを実行しようとするとコンパイルエラーになります（コメントアウト解除して確認してみてください）
        // System.out.println("変更しようとしたPI: " + PI);
```

*   **`final`キーワード**:  
    `final`は「最終的な」「これ以上変更できない」という意味を持ちます。  
    変数に`final`を付けると、その変数は一度値が代入された後、それ以降は値を変更しようとするとコンパイルエラーになります。  
    これは、円周率(`PI`)やアプリケーションのバージョン(`APP_VERSION`)、最大値や税率など、プログラムの実行中に絶対に変わってはいけない値を定義するのに最適です。  
    `final`は変数だけでなく、メソッドやクラスにも適用でき、それぞれ異なる意味（オーバーライド禁止、継承禁止）を持ちます。  

*   **定数の利点**:  
    *   **安全性**: 誤って値を変更してしまうバグを防ぐことができます。  
    *   **可読性**: コードを読んだときに、その値が不変であることが一目でわかります。  
    *   **保守性**: もし定数の値を変更する必要が生じた場合でも、一箇所だけ変更すればよく、コード全体を探して修正する必要がありません。  

*   **命名慣習**:  
    定数名は慣習として**すべて大文字**で記述し、複数の単語はアンダースコア (`_`) で繋ぎます。  
    例: `final double PI = 3.14159;`, `final String APP_VERSION = "1.0.0";`  
    この命名規則により、コード中でその識別子が「定数である」とすぐに判別でき、誤って再代入しようとするのを防ぐ効果もあります。  

---

### 6. 変数のスコープ

変数の「スコープ（Scope）」とは、その変数がプログラムのどの範囲で利用可能か（「生きている」か）を示すものです。  
変数は宣言されたブロック（`{}`で囲まれた範囲）内でしか利用できません。  
スコープは変数の「寿命」とも言えます。  

```java showLineNumbers
        System.out.println("\n--- 6. 変数のスコープ ---");
        // 変数には「スコープ」と呼ばれる有効範囲があります。
        // 変数は宣言されたブロック（{}で囲まれた範囲）内でしか利用できません。
        { // ここから新しいブロック
            int innerValue = 100; // このinnerValueは{}のブロック内でのみ有効
            System.out.println("ブロック内のinnerValue: " + innerValue);
        } // ここでブロックが終了し、innerValueは消滅します

        // System.out.println("ブロック外のinnerValue: " + innerValue); // ← innerValueはここで利用できないため、コンパイルエラーになります

        // mainメソッド内で宣言されたageやnameなどの変数は、mainメソッド全体で有効です。
        System.out.println("mainメソッド内のage (スコープOK): " + age);
```

*   **ブロックスコープ**:  
    Javaでは、変数はそれを宣言した`{}`（ブロック）の中からのみアクセスできます。  
    ブロックの外に出ると、その変数は存在しなくなります（メモリから解放される可能性があります）。  
    例の`innerValue`は、`{}`で囲まれた小さなブロックの中で宣言されているため、そのブロックが終了すると、`innerValue`は利用できなくなります。  
    ブロックの閉じ括弧（`}`）が変数の「寿命の終わり」を示します。  

*   **メソッドスコープ**:  
    このサンプルコードでいう`main`メソッドのように、メソッド内で宣言された変数は、そのメソッド全体で有効です。  
    `age`や`name`といった変数は`main`メソッドのブロック内で宣言されているため、`main`メソッドが終了するまで（つまりプログラムの実行中、この部分では）どこでも利用できます。  

*   **ネストされたスコープ**:  
    ブロックの中にさらにブロック（ネストされたブロック）がある場合、内側のブロックからは外側のブロックで宣言された変数を参照できます。  
    しかし、外側のブロックからは内側のブロックで宣言された変数を参照することはできません。  
    これは、内側のブロックが外側のブロックの「一部」だからです。  

スコープを理解することは、変数の意図しない衝突を防ぎ、メモリ使用量を最適化し、より整理されたコードを書く上で非常に重要です。  

---

### 7. 型変換（キャスト）

異なるデータ型間で値を変換することを「型変換（キャスト）」と呼びます。  
これは、異なる型の変数に値を代入したり、異なる型の値を演算したりする際に必要となる処理です。  

```java showLineNumbers
        System.out.println("\n--- 7. 型変換（キャスト） ---");
        // 異なるデータ型間で値を変換することを「型変換（キャスト）」と呼びます。

        // 1. 暗黙的な型変換（自動型変換、Widening Conversion）
        // 小さいデータ型から大きいデータ型への変換は、データが失われる心配がないため自動で行われます。
        int myInt = 10;
        double myDouble = myInt; // intからdoubleへ自動的に変換される
        System.out.println("intからdoubleへの暗黙的変換: " + myDouble);

        // 2. 明示的な型変換（強制型変換、Narrowing Conversion）
        // 大きいデータ型から小さいデータ型への変換は、データが失われる可能性があるため、
        // プログラマーが`(変換したい型)`という形で明示的に指示する必要があります。
        double largeNumber = 123.789;
        int castedNumber = (int) largeNumber; // doubleからintへ明示的にキャスト
        // 小数点以下は切り捨てられます。
        System.out.println("doubleからintへの明示的変換 (小数点以下切り捨て): " + castedNumber);

        // 値が範囲を超える場合の例（注意が必要です）
        int veryLargeInt = 200;
        byte castedByte = (byte) veryLargeInt; // byteの最大値は127。200は入りきらない。
        // 結果は-56となります（オーバーフロー/アンダーフロー）。
        System.out.println("intからbyteへの明示的変換 (値が範囲を超過): " + castedByte);
```

#### 7.1. 1. 暗黙的な型変換（Widening Conversion / 拡大変換）

*   **特徴**:  
    小さいデータ型から大きいデータ型（例えば`int`から`double`）への変換は、データが失われる心配がないため、Javaが**自動的に**行ってくれます。  
    この変換は「安全な変換」とみなされます。  
*   **例**:  
    `int myInt = 10;`  
    `double myDouble = myInt;` // `int`型の`10`は、自動的に`double`型の`10.0`に変換されます。  
    これは、`double`型が`int`型よりも広い範囲の数値を表現でき、かつ小数点を扱えるため、情報を失うことなく変換できるからです。  

*   **変換の順序（小さい → 大きい）**:  
    `byte` → `short` → `int` → `long` → `float` → `double`  
    `char` → `int` (charの文字コードがintとして扱われる)  

#### 7.2. 2. 明示的な型変換（Narrowing Conversion / 縮小変換、強制型変換、キャスト）

*   **特徴**:  
    大きいデータ型から小さいデータ型への変換は、データが失われる可能性があるため、プログラマーが**明示的に指示**する必要があります。  
    `(変換したい型)値`という形式で記述します。  
    この変換は「安全でない可能性がある変換」とみなされ、プログラマーがそのリスクを認識していることを示すために明示的なキャストが求められます。  
*   **例（小数点以下の切り捨て）**:  
    `double largeNumber = 123.789;`  
    `int castedNumber = (int) largeNumber;` // `double`から`int`へ明示的にキャスト。  
    この場合、`int`型は小数点を扱えないため、小数点以下は**切り捨てられます**（四捨五入ではありません）。  
    結果として`castedNumber`には`123`が代入されます。  

*   **例（値の範囲超過 / オーバーフロー・アンダーフロー）**:  
    `int veryLargeInt = 200;`  
    `byte castedByte = (byte) veryLargeInt;` // `byte`の最大値は127。`200`は`byte`の範囲を超えています。  
    この場合、結果は`-56`となります。  
    これは、`byte`型が8ビットで表現できる最大値を超えたため、値が一周して最小値側に戻ってしまう「オーバーフロー」という現象です。  
    このように、明示的なキャストはデータが意図しない値になる可能性があるため、特に注意が必要です。  
    適切な範囲チェックを行うなど、細心の注意を払う必要があります。  

*   **文字と数値の型変換**:  
    `char`型は内部的にはUnicodeの数値として扱われるため、`int`型と相互にキャスト可能です。  
    `int charCode = (int) 'A';` (`charCode`は65となる)  
    `char charVal = (char) 65;` (`charVal`は'A'となる)  


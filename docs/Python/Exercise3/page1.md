---
sidebar_position: 1
---

# アルゴリズム課題

## 部分ソートの実装
---

与えられた以下の整数のリスト `nums` と、2つのインデックス `start` と `end` が与えられたとき、  
`nums` の `start` から `end` までの部分リストをソートしてください。ただし、元のリスト `nums` を変更してください。

```Python
nums = [5, 2, 8, 1, 9, 4]
start = 1
end = 4
```

期待する出力結果：
```
部分ソート後のリスト: [5, 1, 2, 8, 9, 4]
```

## マージソートの実装
---

与えられた以下のタプルのリスト `data` を、各タプルの2番目の要素に基づいてソートを行ってください。  

```Python
data = [("apple", 3), ("banana", 1), ("cherry", 2), ("date", 1), ("elderberry", 3)]
```

期待する出力結果：
```
ソート結果: [('banana', 1), ('date', 1), ('cherry', 2), ('apple', 3), ('elderberry', 3)]
```

## 深さ優先探索による組み合わせ列挙
---

与えられた整数のリスト `nums` から、指定された長さ `k` の組み合わせをすべて列挙してください。

```Python
nums = [1, 2, 3, 4]
k = 2
```
期待する出力結果：
```
[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
```


## ダイクストラ法による最短経路探索
---

以下のグラフにおいて、頂点Aから各頂点への最短経路とその距離をダイクストラ法を用いて求めてください。  
※矢印上の数字は頂点間のコストを表します。

![img](./img/algo1.png)

以下のデータを使用して下さい。
```python
# グラフの定義
graph = {
    'A': {'B': 3, 'C': 5, 'E': 1},
    'B': {'A': 3, 'D': 4, 'E': 1, 'F':3},
    'C': {'A': 5, 'E': 3},
    'D': {'B': 4},
    'E': {'A': 1, 'B': 1, 'C': 3, 'F': 2},
    'F': {'B': 3, 'E': 2}
}
```

期待する出力結果：
```
A -> A: 0
A -> B: 2
A -> C: 4
A -> D: 4
A -> E: 1
A -> F: 3
```

<details>
    <summary>Hint</summary>
### 初期化:

頂点Aからの距離を0、他の頂点への距離を無限大とします。  
未訪問の頂点の集合を(A, B, C, D, E, F)とします。  

### 反復:

未訪問の頂点の中で、Aからの距離が最小の頂点を選択します。ここではAが選択されます。  
Aから直接つながっている頂点B, C, Eへの距離を更新します。  

- A -> B: 2  
- A -> C: 5  
- A -> E: 1  

Aを訪問済みにします。未訪問の頂点の集合は(B, C, D, E, F)となります。  
未訪問の頂点の中で、Aからの距離が最小の頂点を選択します。ここではEが選択されます。  
Eから直接つながっている頂点B, C, D, Fへの距離を更新します。  

- A -> E -> B: 1 + 1 = 2 (更新なし)  
- A -> E -> C: 1 + 3 = 4  
- A -> E -> D: 1 + 3 = 4  
- A -> E -> F: 1 + 2 = 3  

Eを訪問済みにします。未訪問の頂点の集合は(B, C, D, F)となります。  
同様の手順を繰り返し、最終的に以下の最短経路と距離が得られます。  

- A -> A: 0  
- A -> B: 2  
- A -> C: 4  
- A -> D: 4  
- A -> E: 1  
- A -> F: 3  
</details>


## 動的計画法によるナップサック問題
---

以下の品物のリストとナップサックの容量が与えられたとき、  
ナップサックに入れる品物の価値の合計を最大化してください。  
※ナップサックの容量は`50`とします。  
※重複する品物は入れられないものとします。  

|品物|価値|重さ(コスト)|
|---|---|---|
|A|10|5|
|B|30|10|
|C|60|20|
|D|120|30|
|E|150|35|

以下のデータを使用して下さい。
```python
# 品物の価値と重さ(コスト)
values = [10, 30, 60, 120, 150]
weights = [5, 10, 20, 30, 35]
```

期待する出力結果：
```
最大価値: 190
選んだ品物 (インデックス): [4, 1, 0]
```

<details>
    <summary>Hint</summary>
### テーブルの作成:
品物の数とナップサックの容量に基づいて、テーブルを作成します。  
テーブルの各セルには、その時点での最大価値を格納します。  

### テーブルの初期化:
テーブルの最初の行と列を0で初期化します。  

### テーブルの更新:
各品物について、ナップサックの容量を1ずつ増やしながら、テーブルを更新します。  
各セルについて、以下のいずれか大きい方の値を格納します。  
前の行の同じ列の値（品物を入れない場合）  
現在の品物の価値 + 前の行の（現在の容量 - 現在の品物の重さ）列の値（品物を入れる場合）  

### 最大価値の取得:
テーブルの右下のセルに、最大価値が格納されます。  
上記のテーブルを埋めていくと最終的に最大価値は220となり、品物BとCを選択したときに最大となります。  
</details>